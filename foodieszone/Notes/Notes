1. This project is of a food odering website that will allow you to order food online. 
Until now the concepts covered are props, components, JSX 

2. Config Driven UI: - controlling your ui using data using config, the config comes from backend for example on zomato the coupons at Dehradun or Delhi might be different and we need to display them on the carosel of our web app then is it possible to show it with different UI? will we need to create different UI for every location? ANSWER  IS NO, and here is the point where the config driven UI conmes into play where the UI depends on data coming from backend. We have written UI once now depending on the data coming from the backend the UI gets changed accordingly. 

3. Cloudinary: its a CDN (content delivery network) here swiggly puts all its images 

4. Why Key is required in map while rendering the component ? => the key is required because lets say we are rendering many restaurant cards like below

 {/* <RestaurantCard resData={resList[1]} />
        <RestaurantCard resData={resList[2]} />
        <RestaurantCard resData={resList[3]} />
        <RestaurantCard resData={resList[4]} />
        <RestaurantCard resData={resList[5]} />
        <RestaurantCard resData={resList[6]} />
        <RestaurantCard resData={resList[7]} />
        <RestaurantCard resData={resList[8]} />
        <RestaurantCard resData={resList[9]} />
        <RestaurantCard resData={resList[10]} /> 
*/}

after using map the above code becomes 

 {
    resList.map((restaurant) => (
            <RestaurantCard key={restaurant.id} resData = {restaurant}/>
))
}

but the question is why Key is used => so to answer this lets say we have 20 cards to be rendered and what if there is new card that needs to be added in between those cards (at fist position last or maybe in between) then in that case if we are not using the key then react will render all the cards again, because it does not know what acrds are already rendered and which one is newly added, but if we provide the key it will render only that particular card.

5. Can we use index as key? => yes we can use, but IT IS NOT RECOMMENDED WHY => 

{resList.map((restaurant, index) => ( 
            <RestaurantCard key={index} resData = {restaurant}/>
        ))} 

Using the array index as a key in React lists is generally discouraged, especially when the list items can change order, be added, or be removed. This is because React uses the key prop to identify which list items have changed, been added, or been removed, and to efficiently update the DOM.
Here's why using the index as a key can lead to problems:

5.1 Performance Issues:

When the order of items changes (e.g., sorting, adding/removing items in the middle), React cannot accurately identify which items have truly moved versus which are entirely new or removed.
This can lead to unnecessary re-renders of components, as React might re-create components instead of simply reordering them in the DOM, negatively impacting performance, especially in large lists.

5.2 State Management Problems:

If list items have internal state (e.g., input values, checkbox states), using the index as a key can cause this state to be associated with the wrong item after reordering or modifications.
For example, if you have a list of items with input fields and you reorder the list, the input values might "stick" to their original index, even though the actual item content has moved, leading to incorrect data display.

5.3 Unpredictable Behavior with Animations and Transitions:

Animations and transitions that rely on stable component identities can behave unexpectedly when index keys are used, as React might not be able to correctly track the elements during these operations.

---------------------------------------------------------------------------------------------------------------

1. useEffect works after the rendering if dependency array is empty 

2. Understanding the CORS Issue and the Proxy Server Solution
This document explains the common CORS (Cross-Origin Resource Sharing) issue in web development and provides a professional, "backend" solution using a proxy server, which is the standard approach when browser extensions are not an option.

3. What is CORS?
CORS stands for Cross-Origin Resource Sharing. To understand it, you first need to know about the Same-Origin Policy.

4. The Same-Origin Policy is a fundamental security feature built into all modern web browsers. It's a simple rule: a web page served from one origin (domain, protocol, and port) is not allowed to make requests to a different origin.

Origin 1: https://your-app.com:443

Origin 2: https://api.third-party.com:443

When your React app (Origin 1) tries to fetch data from the Swiggy API (Origin 2), the browser sees this as a "cross-origin" request. By default, it blocks this request to prevent malicious websites from stealing your data or making unauthorized requests on your behalf.

The API server can explicitly tell the browser that it's okay to accept requests from a different origin by sending a special header called Access-Control-Allow-Origin in its response. If the API doesn't send this header, the browser will block the response, and you get the dreaded CORS error.

use CORS Allow Extension 

With this setup, your React application will be able to successfully fetch data from the API without encountering any CORS errors, providing a robust and scalable solution for your project. This approach is standard practice in professional development and ensures your application works for all users, regardless of their browser settings or extensions.

5. Why we have state variables => we have state variables to let know react when to update the UI, a normal javascript vriable when changed will not have capacity to update the UI or re-render it. This is why we have state variables and thus it is used to change the state. 

6. const value cannot be changed but still we use const to create a atate variable for useState why so? => 

The const Keyword in useState
const in const [variable, setVariable] = useState() doesn't mean the variable's value can't change. It means the variable identifier cannot be re-assigned.

How useState Works
useState is a React Hook that provides a way to add state to functional components. When you call it, it returns an array with two elements:

The current state value (variable).

A function to update that state (setVariable).

The Crucial Connection
The apparent contradiction is resolved by understanding how React re-renders components.

When you call setVariable(newValue):

1. React doesn't change the value of the existing variable directly.

2. Instead, it schedules the component to re-render.

3. During this re-render, the useState() function is called again.

4. This time, useState() returns a new array containing the updated value.

5. The const [variable, setVariable] = ... line then de-structures this new array, effectively assigning the updated value to the variable identifier.

Essentially, with each re-render, a new const variable is created. The const rule is never broken because you are not re-assigning the original variable; you are simply getting a new one with the updated value in each render cycle.